<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Space Invaders</title>
</head>

<body>
  <div id="content">
    <div id="canvasContainer">
      <canvas id="canvas"></canvas>
    </div>
    <div id="gameOverPanel">
      <span id="replayButton" onclick="replay()">Replay</span>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/polygon-clipping@0.15.7/dist/polygon-clipping.umd.min.js"></script>
  <script>
    const poly1 = [[[0, 1], [0, 2], [3, 2], [3, 1]]]
    const poly2 = [[[1, 0], [1, 3], [2, 3], [2, 0]]]
    const difference = this.polygonClipping.difference(poly1, poly2)
    console.log("difference:", difference)
    Math.directionToRadian = (direction) => {
      return 2 * Math.PI * direction
    }
    Math.getRandomInt = (max) => {
      return Math.round(Math.random() * max);
    }

    let isMobile = false;
    (function (a) { if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(a) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4))) isMobile = true; })(navigator.userAgent || navigator.vendor || window.opera);

    const Direction = { RIGHT: 0, DOWN: 0.25, LEFT: 0.5, UP: 0.75 }

    class Shape {
      image = undefined
      width = 0
      height = 0
      constructor({ image, width, height } = {}) {
        this.image = image
        this.width = width ?? 0
        this.height = height ?? 0
      }
    }

    function getSvgImage(svg) {
      const img = new Image()
      img.src = `data:image/svg+xml;utf8,${encodeURIComponent(svg)}`
      return img
    }

    const backgroundSvg = ({ color = '#000000', opacity = 1 } = {}) => `<svg viewBox="0 0 1 1" xmlns="http://www.w3.org/2000/svg"><rect x='0' y='0' width='1' height='1' fill="${color}" opacity="${opacity}" /></svg>`
    const playerSvg = ({ color = '#00ff00', opacity = 1 } = {}) => `<svg viewBox="0 0 13 8" xmlns="http://www.w3.org/2000/svg"><path d="M 0 8 L 0 4 L 1 4 L 1 3 L 5 3 L 5 1 L 6 1 L 6 0 L 7 0 L 7 1 L 8 1 L 8 3 L 12 3 L 12 4 L 13 4 L 13 8 Z" fill="${color}" opacity="${opacity}" /></svg>`
    const alien1Svg = ({ color = '#ffffff', opacity = 1 } = {}) => `<svg viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><path d="M 0 3 L 1 3 L 1 2 L 2 2 L 2 1 L 3 1 L 3 0 L 5 0 L 5 1 L 6 1 L 6 2 L 7 2 L 7 3 L 8 3 L 8 5 L 7 5 L 7 6 L 8 6 L 8 7 L 7 7 L 7 8 L 6 8 L 6 7 L 7 7 L 7 6 L 6 6 L 6 3 L 5 3 L 5 4 L 6 4 L 6 5 L 5 5 L 5 6 L 3 6 L 3 3 L 2 3 L 2 4 L 3 4 L 3 5 L 2 5 L 2 6 L 1 6 L 1 7 L 2 7 L 2 8 L 1 8 L 1 7 L 0 7 L 0 6 L 1 6 L 1 5 L 0 5 Z" fill="${color}" opacity="${opacity}" /></svg>`
    const alien2Svg = ({ color = '#ffffff', opacity = 1 } = {}) => `<svg viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg"><path d="M 0 5 L 0 3 L 1 3 L 1 2 L 2 2 L 2 1 L 3 1 L 3 0 L 5 0 L 5 1 L 6 1 L 6 2 L 7 2 L 7 3 L 8 3 L 8 5 L 6 5 L 6 3 L 5 3 L 5 4 L 6 4 L 6 5 L 3 5 L 3 3 L 2 3 L 2 4 L 3 4 L 3 5 Z M 5 6 L 5 5 L 6 5 L 6 6 L 7 6 L 7 7 L 8 7 L 8 8 L 7 8 L 7 7 L 6 7 L 6 6 L 5 6 L 5 7 L 6 7 L 6 8 L 5 8 L 5 7 L 3 7 L 3 8 L 2 8 L 2 7 L 1 7 L 1 8 L 0 8 L 0 7 L 1 7 L 1 6 L 2 6 L 2 5 L 3 5 L 3 6 L 2 6 L 2 7 L 3 7 L 3 6 Z" fill="${color}" opacity="${opacity}" /></svg>`
    const bulletSvg = ({ color = '#ffffff', opacity = 1 } = {}) => `<svg viewBox="0 0 1 3" xmlns="http://www.w3.org/2000/svg"><rect x='0' y='0' width='1' height='3' fill="${color}" opacity="${opacity}" /></svg>`
    const barricadeSvg = ({ color = '#00ff00', opacity = 1 } = {}) => `<svg viewBox="0 0 8 6" xmlns="http://www.w3.org/2000/svg"><path d="M 0 6 L 0 2 L 2 0 L 6 0 L 8 2 L 8 6 L 6 6 L 6 5 L 5 4 L 3 4 L 2 5 L 2 6 Z" fill="${color}" opacity="${opacity}" /></svg>`

    const bgShape = new Shape({
      image: getSvgImage(backgroundSvg()),
      width: 1,
      height: 1
    })

    const playerShape = new Shape({
      image: getSvgImage(playerSvg()),
      width: 8,
      height: 5
    })
    const playerCollider = {
      tag: ['player'],
      vertices: [[
        [0, 8],
        [0, 4],
        [1, 4],
        [1, 3],
        [5, 3],
        [5, 1],
        [6, 1],
        [6, 0],
        [7, 0],
        [7, 1],
        [8, 1],
        [8, 3],
        [12, 3],
        [12, 4],
        [13, 4],
        [13, 8],
        [0, 8],
      ]],
      width: 8,
      height: 8
    }

    const alien1_1Shape = new Shape({
      image: getSvgImage(alien1Svg()),
      width: 8,
      height: 8
    })
    const alien1_2Shape = new Shape({
      image: getSvgImage(alien2Svg()),
      width: 8,
      height: 8
    })
    const alien1Collider = {
      tag: ['enemy'],
      vertices: [[
        [0, 0],
        [0, 8],
        [8, 8],
        [8, 0],
        [0, 0],
      ]],
      width: 8,
      height: 8
    }

    const bulletShape = new Shape({
      image: getSvgImage(bulletSvg()),
      width: 1,
      height: 3
    })
    const bulletCollider = {
      tag: ['bullet'],
      vertices: [[
        [0, 0],
        [0, 3],
        [1, 3],
        [1, 0],
        [0, 0],
      ]],
      width: 1,
      height: 3
    }

    const barricadeShape = new Shape({
      image: getSvgImage(barricadeSvg()),
      width: 8,
      height: 6
    })
    const barricadeCollider = {
      tag: ['barricade'],
      vertices: [[
        [0, 6],
        [0, 2],
        [2, 0],
        [6, 0],
        [8, 2],
        [8, 6],
        [6, 6],
        [6, 5],
        [5, 4],
        [3, 4],
        [2, 5],
        [2, 6],
        [0, 6],
      ]],
      width: 8,
      height: 6
    }


    const config = {
      dp: 1,
      canvas: {
        width: 100,
        height: 100
      },
      canvasContext: undefined,
      player: {
        width: 7
      },
      playerFire: {
        width: 0.5,
        height: 1.5,
        speed: 120
      },
      enemyFire: {
        width: 0.5,
        height: 1.5,
        speed: 40
      },
      enemyGroup: {
        counts: { rows: 5, cols: 11 },
        spaces: { vertical: 2, horizontal: 2 },
      },
      barricade: {
        count: 4
      }
    }


    class Game {
      gameObjects = []
      keyState = {}
      isPlaying = false
      gameStartTime = 0
      lastDrawTime = 0
      deltaTime = 0
      collisionTagPairs = undefined
      listeners = {
        gameOver: []
      }
      polygonClipping = undefined

      constructor({ gameObjects, collisionTagPairs, polygonClipping } = {}) {
        if (gameObjects) {
          this.gameObjects = gameObjects
        }
        if (collisionTagPairs) {
          this.collisionTagPairs = collisionTagPairs
        }
        if (polygonClipping) {
          this.polygonClipping = polygonClipping
        }
      }

      play() {
        this.isPlaying = true
        this.gameStartTime = Date.now()
      }

      gameOver() {
        this.isPlaying = false
        this.notify('gameOver')
      }

      draw() {
        const { canvasContext, dp } = config
        const { deltaTime, lastDrawTime, isPlaying, gameObjects } = this
        if (canvasContext && isPlaying) {
          this.deltaTime = (Date.now() - lastDrawTime) / 1000
          this.lastDrawTime = Date.now()
          this.checkCollisions()
          canvasContext.reset()
          gameObjects.forEach(gameObject => {
            if (gameObject.onFrame) {
              gameObject.onFrame({ deltaTime })
            }
            if (gameObject.draw) {
              gameObject.draw()
            }
          });
        }
      }

      add(...gameObjects) {
        gameObjects.forEach(gameObject => {
          gameObject.game = this
          gameObject.index = this.gameObjects.length
          this.gameObjects.push(gameObject)
        });
      }

      addAt(index, ...gameObjects) {
        gameObjects.forEach((gameObject, i) => {
          gameObject.game = this
          gameObject.index = index + i
        });
        this.gameObjects = [
          ...this.gameObjects.slice(0, index),
          ...gameObjects,
          ...this.gameObjects.slice(index)
        ];
      }

      remove(gameObject) {
        const index = this.gameObjects.findIndex(item => item == gameObject)
        if (index > -1) {
          this.gameObjects.splice(index, 1)
        }
      }

      removeAt(index, deleteCount = 1) {
        return this.gameObjects.splice(index, deleteCount)
      }

      getAt(index) {
        return this.gameObjects[index]
      }

      getAll() {
        return this.gameObjects
      }

      getByTag(tag) {
        if (Array.isArray(tag)) {
          return this.gameObjects.filter(item => tag.every(t => item.hasTag(t)))
        }
        else if (typeof tag == 'string') {
          return this.gameObjects.filter(item => item.hasTag(tag))
        } else {
          return []
        }
      }

      indexOf(gameObject) {
        return this.gameObjects.indexOf(gameObject)
      }

      clear() {
        this.gameObjects = []
      }

      addCollisionTagPairs(...collisionTagPairs) {
        this.collisionTagPairs = this.collisionTagPairs ?? []
        this.collisionTagPairs.push(...collisionTagPairs)
      }

      clearCollisionTagPairs() {
        this.collisionTagPairs = undefined
      }

      on(eventName, callback) {
        this.listeners[eventName].push(callback)
      }

      off(eventName, callback) {
        if (this.listeners[eventName]?.length) {
          const indexes = []
          this.listeners[eventName].forEach((listener, i) => {
            if (listener === callback) {
              indexes.push(i)
            }
          });
          for (let i = indexes.length - 1; i <= 0; i--) {
            const index = indexes[i];
            this.listeners[eventName].splice(index, 1)
          }
        }
      }

      notify(eventName, data) {
        if (this.listeners[eventName]?.length) {
          this.listeners[eventName].forEach((listener) => {
            if (listener) {
              listener(data)
            }
          });
        }
      }

      checkCollisions() {
        if (this.collisionTagPairs == undefined || this.collisionTagPairs.length > 0) {
          const gameObjects = this.gameObjects.filter(gameObject => gameObject.colliders.length)
          if (gameObjects.length > 1) {
            for (let i = 0; i < gameObjects.length; i++) {
              for (let j = i + 1; j < gameObjects.length; j++) {
                const gameObject1 = gameObjects[i];
                const gameObject2 = gameObjects[j];
                if (gameObject1.colliders?.length && gameObject2.colliders?.length) {
                  for (let k = 0; k < gameObject1.colliders.length; k++) {
                    for (let l = 0; l < gameObject2.colliders.length; l++) {
                      const collider1 = gameObject1.colliders[k]
                      const collider2 = gameObject2.colliders[l]
                      const shouldCheck = this.collisionTagPairs == undefined || this.collisionTagPairs.some(pair => {
                        return (collider1.hasTag(pair[0]) && collider2.hasTag(pair[1])) ||
                          (collider1.hasTag(pair[1]) && collider2.hasTag(pair[0]))
                      })
                      if (shouldCheck) {
                        for (let m = 0; m < collider1.vertices.length; m++) {
                          for (let n = 0; n < collider2.vertices.length; n++) {
                            const vertexGroup1 = collider1.vertices[m];
                            const vertexGroup2 = collider2.vertices[n];
                            if (this.polyPolyCollision(vertexGroup1, vertexGroup2)) {
                              if (gameObject1.onCollide) {
                                gameObject1.onCollide({
                                  collider: collider1,
                                  otherCollider: collider2,
                                  vertexGroup: vertexGroup1,
                                  vertexGroupIndex: m,
                                  otherVertexGroup: vertexGroup2,
                                  otherVertexGroupIndex: n
                                })
                              }
                              if (gameObject2.onCollide) {
                                gameObject2.onCollide({
                                  collider: collider2,
                                  otherCollider: collider1,
                                  vertexGroup: vertexGroup2,
                                  vertexGroupIndex: n,
                                  otherVertexGroup: vertexGroup1,
                                  otherVertexGroupIndex: m
                                })
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

      polyPolyCollision(p1, p2) {
        if (p1 && p2) {
          let next = 0;
          for (let current = 0; current < p1.length; current++) {
            next = current + 1;
            if (next == p1.length) next = 0;
            const vc = p1[current];
            const vn = p1[next];
            if (this.polyLineCollision(p2, vc[0], vc[1], vn[0], vn[1])) {
              return true
            }
            if (this.polyPointCollision(p1, p2[0][0], p2[0][1])) {
              return true
            }
          }
        }
        return false;
      }

      polyLineCollision(vertices, x1, y1, x2, y2) {
        let next = 0;
        for (let current = 0; current < vertices.length; current++) {
          next = current + 1;
          if (next == vertices.length) next = 0;
          let x3 = vertices[current][0];
          let y3 = vertices[current][1];
          let x4 = vertices[next][0];
          let y4 = vertices[next][1];
          if (this.lineLineCollision(x1, y1, x2, y2, x3, y3, x4, y4)) {
            return true;
          }
        }
        return false;
      }

      lineLineCollision(x1, y1, x2, y2, x3, y3, x4, y4) {
        let uA = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        let uB = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));
        if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
          return true;
        }
        return false;
      }

      polyPointCollision(vertices, px, py) {
        let collision = false;
        let next = 0;
        for (let current = 0; current < vertices.length; current++) {
          next = current + 1;
          if (next == vertices.length) next = 0;
          let vc = vertices[current];
          let vn = vertices[next];
          if (((vc[1] > py && vn[1] < py) || (vc[1] < py && vn[1] > py)) &&
            (px < (vn[0] - vc[0]) * (py - vc[1]) / (vn[1] - vc[1]) + vc[0])) {
            collision = !collision;
          }
        }
        return collision;
      }
    }


    class GameObject {
      tag = []
      position = { x: 0, y: 0 }
      width = 0
      height = 0
      scale = { x: 1, y: 1 }
      rotation = 0
      shape = new Shape()
      colliders = []
      game = undefined
      index = -1
      children = []
      parent = undefined

      constructor(args = {}) {
        const { tag, shape, colliders, position, scale, width, height, rotation } = args
        if (Array.isArray(tag)) {
          this.tag = tag
        } else if (typeof tag == 'string') {
          this.tag.push(tag)
        }
        if (shape) {
          this.shape = shape
        }
        if (Array.isArray(colliders)) {
          this.colliders = colliders
          this.colliders.forEach(collider => {
            collider.gameObject = this
          })
        }
        if (position) {
          this.position.x = typeof position.x == 'number' ? position.x : this.position.x
          this.position.y = typeof position.y == 'number' ? position.y : this.position.y
        }
        if (rotation != undefined) {
          this.rotation = rotation
        }
        if (typeof scale == 'object' && !Array.isArray(scale)) {
          this.scale = {
            x: scale.x === undefined ? scale.y ?? this.scale.x : scale.x,
            y: scale.y === undefined ? scale.x ?? this.scale.y : scale.y,
          }
        } else if (typeof scale == 'number') {
          this.scale = {
            x: scale,
            y: scale,
          }
        } else if (width != undefined || height != undefined) {
          this.setSize(width, height)
        }
      }

      draw() {
        const { canvasContext, dp } = config
        if (canvasContext) {
          if (this.shape.image) {
            const { position, width, height } = this
            canvasContext.drawImage(this.shape.image, position.x * dp, position.y * dp, width * dp, height * dp)
          }
        }
      }

      hasTag(tag) {
        return this.tag.includes(tag)
      }

      addTag(tag) {
        this.tag.push(tag)
      }

      removeTag(tag) {
        const index = item.tag.findIndex(t => t == tag)
        if (index > -1) {
          item.tag.splice(index, 1)
        }
      }

      clearTag() {
        item.tag = []
      }

      scaleTo(x, y) {
        if (x != undefined) {
          this.scale.x = x
          this.scale.y = y === undefined ? x : y
          this.width = this.shape.width * this.scale.x
          this.height = this.shape.height * this.scale.y
          this.notifyCollidersDataChanged()
          return this.scale
        }
        return false
      }

      scale(x, y) {
        if (x != undefined) {
          this.scale.x *= x
          this.scale.y *= y === undefined ? x : y
          this.notifyCollidersDataChanged()
          return this.scale
        }
        return false
      }

      setSize(width, height) {
        if (width != undefined || height != undefined) {
          const scaleX = width != undefined ? width / this.shape?.width : height / this.shape?.height
          const scaleY = height != undefined ? height / this.shape?.height : width / this.shape?.width
          return this.scaleTo(scaleX, scaleY)
        }
        return false
      }

      move(x, y) {
        if (x || y) {
          this.position.x += (x || 0)
          this.position.y += (y || 0)
          this.notifyCollidersDataChanged()
          return this.position
        }
        return false
      }

      moveTo(x, y) {
        if (x != undefined || y != undefined) {
          if (x != undefined) {
            this.position.x = x
          }
          if (y != undefined) {
            this.position.y = y
          }
          this.notifyCollidersDataChanged()
          return this.position
        }
        return false
      }

      moveTowards(direction, distance) {
        if (direction != undefined && distance) {
          const rad = Math.directionToRadian(this.direction)
          this.position.x += Math.cos(rad) * distance
          this.position.y += Math.sin(rad) * distance
          this.notifyCollidersDataChanged()
          return this.position
        }
        return false
      }

      addCollider(collider) {
        if (collider instanceof Collider) {
          collider.parent = this
          this.colliders.push(collider)
          collider.onParentDataChanged()
          return true
        }
        return false
      }

      removeCollider(collider) {
        if (collider && collider instanceof Collider) {
          const index = this.colliders.findIndex(c => c === collider)
          if (index > -1) {
            this.colliders.splice(index, 1)
            return true
          }
        }
        return false
      }

      removeColliderAt(index) {
        if (this.colliders.splice(index, 1)) return true
        return false
      }

      notifyCollidersDataChanged() {
        this.colliders.forEach(collider => {
          if (collider.onParentDataChanged) {
            collider.onParentDataChanged()
          }
        })
      }
    }


    class Collider {
      tag = []
      initialData = {
        width: 0,
        height: 0,
        vertices: []
      }
      position = { x: 0, y: 0 }
      scenePosition = { x: 0, y: 0 }
      width = 0
      height = 0
      scale = { x: 1, y: 1 }
      vertices = []
      parent = undefined

      constructor(args = {}) {
        const { tag, vertices, width, height } = args
        if (tag) {
          if (Array.isArray(tag)) {
            this.tag = tag
          } else if (typeof tag == 'string') {
            this.tag.push(tag)
          }
        }
        if (vertices) this.vertices = vertices
        if (typeof width == 'number') this.width = width
        if (typeof height == 'number') this.height = height
        this.initialData.width = this.width
        this.initialData.height = this.height
        this.initialData.vertices = JSON.parse(JSON.stringify(this.vertices))
      }

      updateVertices() {
        this.vertices = this.initialData.vertices.map(vertexGroup => {
          return vertexGroup.map(vertex => {
            const newVertexGroup = []
            // Scale
            newVertexGroup[0] = vertex[0] * this.scale.x
            newVertexGroup[1] = vertex[1] * this.scale.y

            // Move
            newVertexGroup[0] += this.scenePosition.x
            newVertexGroup[1] += this.scenePosition.y

            // TODO: Rotate

            return newVertexGroup
          })
        })
      }

      setSize(width, height) {
        if (width != undefined || height != undefined) {
          const scaleX = width != undefined ? width / this.initialData.width : height / this.initialData.height
          const scaleY = height != undefined ? height / this.initialData.height : width / this.initialData.width
          return this.scaleTo(scaleX, scaleY)
        }
        return false
      }

      scale(x, y) {
        if (x != undefined) {
          this.scale.x *= x
          this.scale.y *= y === undefined ? x : y
          this.width *= x
          this.height *= y === undefined ? x : y
          this.updateVertices()
          return this.scale
        }
        return false
      }

      scaleTo(x, y) {
        if (x != undefined) {
          this.scale.x = x
          this.scale.y = y === undefined ? x : y
          this.width = this.initialData.width * x
          this.height = y === undefined ? this.initialData.height * x : this.initialData.height * y
          this.updateVertices()
          return this.scale
        }
        return false
      }

      move(x, y) {
        if (x || y) {
          this.position.x += (x || 0)
          this.position.y += (y || 0)
          this.updateVertices()
          return this.position
        }
        return false
      }

      moveTo(x, y) {
        if (x != undefined || y != undefined) {
          if (x != undefined) {
            this.position.x = x
          }
          if (y != undefined) {
            this.position.y = y
          }
          this.updateVertices()
          return this.position
        }
        return false
      }

      moveTowards(direction, distance) {
        if (direction != undefined && distance) {
          const rad = Math.directionToRadian(this.direction)
          this.position.x += Math.cos(rad) * distance
          this.position.y += Math.sin(rad) * distance
          this.updateVertices()
          return this.position
        }
        return false
      }

      hasTag(tag) {
        return this.tag.includes(tag)
      }

      addTag(tag) {
        this.tag.push(tag)
      }

      removeTag(tag) {
        const index = item.tag.findIndex(t => t == tag)
        if (index > -1) {
          item.tag.splice(index, 1)
        }
      }

      clearTag() {
        item.tag = []
      }

      onParentDataChanged() {
        this.scenePosition = {
          x: this.parent.position.x + this.position.x,
          y: this.parent.position.y + this.position.y
        }
        this.updateVertices()
      }
    }


    class Player extends GameObject {
      constructor(args = {}) {
        args.tag = args.tag ?? 'player'
        args.shape = args.shape ?? playerShape
        super(args)
        this.maxSpeed = args.maxSpeed ?? 50
        this.speed = args.speed ?? 0
        this.direction = args.direction ?? Direction.RIGHT
      }

      onFrame({ deltaTime }) {
        this.moveTowards(this.direction, this.speed * deltaTime)
        if (this.position.x + this.width / 2 > config.canvas.width) {
          this.moveTo(config.canvas.width - this.width / 2)
        }
        else if (this.position.x + this.width / 2 < 0) {
          this.moveTo(-this.width / 2)
        }
      }

      onCollide({ otherCollider }) {
        if (otherCollider.hasTag('enemyFire')) {
          this.game.gameOver()
        }
      }

      goLeft() {
        this.direction = Direction.LEFT
        this.speed = this.maxSpeed
      }

      goRight() {
        this.direction = Direction.RIGHT
        this.speed = this.maxSpeed
      }

      stop() {
        this.speed = 0
      }

      fire() {
        if (!this.game.getByTag('playerFire').length) {
          const bullet = new Bullet({
            tag: ['bullet', 'playerFire'],
            position: {
              x: this.position.x + this.width / 2 - config.playerFire.width / 2,
              y: this.position.y
            },
            width: config.playerFire.width,
            height: config.playerFire.height,
            speed: config.playerFire.speed,
          })
          const colliderBullet = new Collider(bulletCollider)
          colliderBullet.setSize(bullet.width, bullet.height)
          colliderBullet.tag = ['bullet', 'playerFire']
          bullet.addCollider(colliderBullet)
          this.game.addAt(this.index, bullet)
        }
      }
    }


    class EnemyController extends GameObject {
      constructor(args = {}) {
        args.tag = args.tag ?? 'enemyController'
        super(args)
        this.move = {
          delay: 5,
          distance: 1,
          lastEnemyMoveTime: 0,
          lastMovedEnemyIndex: -1,
          toRight: true,
          toDown: false,
          willChangeDirection: false
        }
        this.fire = {
          maxDelay: 5000,
          nextFireTime: 0
        }
        this.fire.nextFireTime = Date.now() + Math.getRandomInt(this.fire.maxDelay)
      }

      onFrame({ deltaTime }) {
        const enemies = game.getByTag('enemy')
        if (enemies.length) {
          const nextEnemyIndexToMove = (this.move.lastMovedEnemyIndex + 1) % enemies.length
          const passedTime = Date.now() - this.move.lastEnemyMoveTime
          if (passedTime >= this.move.delay) {
            enemies[nextEnemyIndexToMove].switchShape()
            if (this.move.toDown) {
              // Move to down
              enemies[nextEnemyIndexToMove].move(0, this.move.distance)
            } else if (this.move.toRight) {
              // Move to right
              const enemy = enemies[nextEnemyIndexToMove]
              enemy.move(this.move.distance)
              if (enemy.position.x + characterSize + this.move.distance > enemyMovementArea.right) {
                this.move.willChangeDirection = true
              }
            } else {
              // Move to left
              const enemy = enemies[nextEnemyIndexToMove]
              enemy.move(-this.move.distance)
              if (enemy.position.x - this.move.distance < enemyMovementArea.left) {
                this.move.willChangeDirection = true
              }
            }

            if (nextEnemyIndexToMove == enemies.length - 1) {
              if (this.move.toDown) {
                this.move.toDown = false
              } else if (this.move.willChangeDirection) {
                this.move.willChangeDirection = false
                this.move.toRight = !this.move.toRight
                this.move.toDown = true
              }
            }

            this.move.lastMovedEnemyIndex = nextEnemyIndexToMove
          }
          this.move.lastEnemyMoveTime = Date.now()

          if (Date.now() >= this.fire.nextFireTime) {
            this.fire.nextFireTime = Date.now() + Math.getRandomInt(this.fire.maxDelay)
            const enemy = enemies[Math.getRandomInt(enemies.length - 1)]
            const bullet = new Bullet({
              tag: ['bullet', 'enemyFire'],
              position: {
                x: enemy.position.x + enemy.width / 2 - config.enemyFire.width / 2,
                y: enemy.position.y
              },
              width: config.enemyFire.width,
              height: config.enemyFire.height,
              direction: Direction.DOWN,
              speed: config.enemyFire.speed
            })
            const colliderBullet = new Collider(bulletCollider)
            colliderBullet.setSize(bullet.width, bullet.height)
            colliderBullet.tag = ['bullet', 'enemyFire']
            bullet.addCollider(colliderBullet)
            this.game.addAt(enemy.index, bullet)
          }
        }
      }

      removeEnemy(enemy) {
        const enemies = this.game.getByTag('enemy')
        if (enemies.length) {
          const index = enemies.findIndex(e => e == enemy)
          if (index > -1) {
            this.game.remove(enemy)
            if (index <= this.move.lastMovedEnemyIndex) {
              this.move.lastMovedEnemyIndex--
            }
          }
        }
      }
    }


    class Enemy extends GameObject {
      constructor(args = {}) {
        args.tag = args.tag ?? 'enemy'
        args.shape = args.shape ?? alien1_1Shape
        super(args)
        this.shapeIndex = 0
      }

      onCollide({ otherCollider }) {
        if (otherCollider.hasTag('playerFire')) {
          const enemyController = this.game.getByTag('enemyController')
          if (enemyController.length) {
            enemyController[0].removeEnemy(this)
          }
          this.game.remove(otherCollider.parent)
        }
      }

      switchShape() {
        this.shapeIndex++
        this.shapeIndex = this.shapeIndex % 2
        this.shape = this.shapeIndex == 0 ? alien1_1Shape : alien1_2Shape
      }
    }


    class Bullet extends GameObject {
      constructor(args = {}) {
        args.tag = args.tag ?? 'bullet'
        args.shape = args.shape ?? bulletShape
        super(args)
        this.speed = args.speed ?? 120
        this.direction = args.direction ?? Direction.UP
      }

      onFrame({ deltaTime }) {
        if (this.position.y - this.height < 0 || this.position.y > config.canvasContext.canvas.height) {
          this.game.remove(this)
        } else {
          this.moveTowards(this.direction, this.speed * deltaTime)
        }
      }

      onCollide({ otherCollider }) {
        if (this.hasTag('enemyFire') && otherCollider.hasTag('playerFire')) {
          this.game.remove(this)
          this.game.remove(otherCollider.parent)
        }
      }
    }


    class Barricade extends GameObject {
      constructor(args = {}) {
        args.tag = args.tag ?? 'barricade'
        args.shape = args.shape ?? barricadeShape
        super(args)
      }

      onCollide({ collider, otherCollider }) {
        if (otherCollider.hasTag('bullet')) {
          const biggerBullet = new Collider({ vertices: otherCollider.vertices, width: otherCollider.width, height: otherCollider.height })
          console.log("Barricade onCollide biggerBullet.vertices:", biggerBullet.vertices)
          console.log("Barricade onCollide collider.vertices:", collider.vertices)
          // biggerBullet.scaleTo(1.5)
          const difference = this.game.polygonClipping?.difference(collider.vertices, biggerBullet.vertices).map(v1 => v1[0].map(v2 => v2))
          console.log("Barricade onCollide difference:", difference)
          collider.vertices = difference
          this.game.remove(otherCollider.parent)
        }
      }
    }




    let game = undefined
    let player = undefined

    let enemies = []
    let enemyMovementArea = { left: 0, right: 0, top: 0, bottom: 0 }
    const levels = [
      {
        enemyFireMaxDelay: 3000
      }
    ]
    let currentLevelIndex = 0
    let currentLevel = levels[0]
    let nextEnemyFireTime = 0

    let characterSize;
    let canvasSizePx;

    window.onload = () => {
      const canvasContainer = document.getElementById('canvasContainer')
      const canvas = document.getElementById("canvas");

      canvasSizePx = Math.min(canvasContainer.offsetWidth, canvasContainer.offsetHeight)
      config.dp = canvasSizePx / 100
      canvas.width = canvasSizePx;
      canvas.height = canvasSizePx;
      config.canvasContext = canvas.getContext("2d");
      enemyMovementArea = { left: 3, right: config.canvas.width - 3, top: 3, bottom: config.canvas.height - 3 }
      characterSize = ((enemyMovementArea.right - enemyMovementArea.left) - (config.enemyGroup.counts.cols - 1) * config.enemyGroup.spaces.horizontal) / (config.enemyGroup.counts.cols + 2)

      window.addEventListener('keydown', function (e) {
        // console.log("keydown e.keyCode:", e.keyCode)
        if (game) {
          game.keyState[e.keyCode || e.which] = true;
          switch (e.keyCode) {
            // Space
            case 32:
              player?.fire()
              break
            // Left
            case 37:
              player?.goLeft()
              break
            // Right
            case 39:
              player?.goRight()
              break
          }
        }
      }, true);
      window.addEventListener('keyup', function (e) {
        if (game) {
          game.keyState[e.keyCode || e.which] = false;
          switch (e.keyCode) {
            // Left
            case 37:
              if (player.direction == Direction.LEFT) {
                player?.stop()
              }
              break
            // Right
            case 39:
              if (player.direction == Direction.RIGHT) {
                player?.stop()
              }
              break
          }
        }
      }, true);

      setInitialData()
      game?.play()
      draw()
    }

    function setInitialData() {
      const { canvas } = config
      game = new Game({
        collisionTagPairs: [
          ['playerFire', 'enemy'],
          ['playerFire', 'enemyFire'],
          ['enemyFire', 'player'],
          ['bullet', 'barricade'],
        ],
        polygonClipping: this.polygonClipping
      })
      game.add(new GameObject({ shape: bgShape, width: canvas.width, height: canvas.height }))
      generateBarricades()
      game.add(new EnemyController())
      generateEnemies()
      const playerHeight = playerShape.height * (config.player.width / playerShape.width)
      player = new Player({
        width: config.player.width,
        position: { x: canvas.width / 2 - config.player.width / 2, y: canvas.height - playerHeight - 3 }
      })
      const colliderPlayer = new Collider(playerCollider)
      colliderPlayer.setSize(player.width, player.height)
      player.addCollider(colliderPlayer)
      game.add(player)
      // game.add(new GameObject({
      //   shape: {
      //     vertices: poly1[0].map(v => ({ x: v[0], y: v[1] })),
      //     color: '#ff0000',
      //     width: 2,
      //     height: 2,
      //   },
      //   scale: 10,
      //   position: { x: 30, y: 50 }
      // }))
      // game.add(new GameObject({
      //   shape: {
      //     vertices: poly2[0].map(v => ({ x: v[0], y: v[1] })),
      //     color: '#00ff00',
      //     width: 1,
      //     height: 1,
      //   },
      //   scale: 10,
      //   position: { x: 30, y: 50 }
      // }))
      // game.add(new GameObject({
      //   shape: {
      //     vertices: difference[0][0].map(v => ({ x: v[0], y: v[1] })),
      //     color: '#0000ff',
      //     width: 2,
      //     height: 2,
      //   },
      //   scale: 10,
      //   position: { x: 30, y: 50 }
      // }))
      game.on('gameOver', () => {
        gameOver()
      })
      const now = Date.now()
    }

    function generateBarricades() {
      for (let i = 0; i < config.barricade.count; i++) {
        const width = config.canvas.width / (config.barricade.count * 2)
        const height = barricadeShape.height * (width / barricadeShape.width)
        const barricade = new Barricade({
          width,
          height,
          position: {
            x: width / 2 + width * i * 2,
            y: config.canvas.width - height - 12
          }
        })
        const colliderBarricade = new Collider(barricadeCollider)
        colliderBarricade.setSize(barricade.width, barricade.height)
        barricade.addCollider(colliderBarricade)
        game.add(barricade)
      }
    }

    function generateEnemies() {
      for (let i = config.enemyGroup.counts.rows - 1; i > -1; i--) {
        for (let j = 0; j < config.enemyGroup.counts.cols; j++) {
          const enemy = new Enemy({
            width: characterSize,
            height: characterSize,
            position: {
              x: j * (characterSize + config.enemyGroup.spaces.horizontal) + enemyMovementArea.left,
              y: i * (characterSize + config.enemyGroup.spaces.vertical) + enemyMovementArea.top
            }
          })
          const colliderAlien1 = new Collider(alien1Collider)
          colliderAlien1.setSize(enemy.width, enemy.height)
          enemy.addCollider(colliderAlien1)
          game.add(enemy)
        }
      }
    }

    function draw() {
      if (game?.isPlaying) {
        game.draw()
        requestAnimationFrame(draw);
      }
    }

    function gameOver() {
      document.getElementById('gameOverPanel').style.display = 'flex'
    }

    function replay() {
      setInitialData()
      game?.play()
      document.getElementById('gameOverPanel').style.display = 'none'
      draw()
    }
  </script>
</body>

<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  html,
  body {
    height: 100%;
    overflow: hidden;
  }

  #content {
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
  }

  #canvasContainer {
    flex: 1;
    align-self: stretch;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #gameOverPanel {
    position: absolute;
    left: 0;
    right: 0;
    top: 0;
    bottom: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background-color: #ff000050;
  }

  #replayButton {
    padding: 10px;
    border-radius: 10px;
    background-color: antiquewhite;
    cursor: pointer;
    user-select: none;
  }
</style>

</html>